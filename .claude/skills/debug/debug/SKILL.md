---
name: debug
description: Debug LangGraph graph execution, state issues, routing problems, tool failures, and general troubleshooting of AOD Engine-generated projects.
---

# AOD Engine Debug

Troubleshoot issues in LangGraph multi-agent systems generated by AOD Engine.

## Common Issues

### 1. Graph Doesn't Respond / Empty Output

**Check**: Is the entry point set?
```python
# In graph.py, verify set_entry_point() points to a real node
builder.set_entry_point("node_name")
```

**Check**: Are there edges from entry to other nodes?
```python
# Verify edges exist
builder.add_edge("source", "target")
```

**Check**: Does the graph compile?
```python
graph = builder.compile()
print(graph.get_graph().draw_mermaid())
```

### 2. Infinite Loop / Agent Never Reaches END

**Check**: The `should_continue` function returns "end" correctly:
```python
def should_continue(state):
    last = state["messages"][-1]
    if hasattr(last, "tool_calls") and last.tool_calls:
        return "tools"
    return "end"  # Must return "end" when no tool calls
```

**Check**: Conditional edges include an END path:
```python
builder.add_conditional_edges("node", route_fn, {
    "route_a": "node_a",
    "__end__": END,  # Must have an exit path
})
```

### 3. Wrong Routing / Messages Going to Wrong Agent

**Check**: Router system prompt includes all available routes
**Check**: Route map keys match what the LLM returns
**Check**: Sticky routing state — is `route_locked` stuck?

```python
# Debug routing state
print(state.get("routing", {}))
print(state.get("route_history", []))
```

### 4. Tool Execution Failures

**Check**: Tool is imported in the agent file
**Check**: Tool is in the tools list passed to ToolNode
**Check**: Tool function signature matches what LLM produces

```python
# List available tools
for tool in tools:
    print(f"{tool.name}: {tool.description}")
```

### 5. State Field Missing / KeyError

**Check**: Field is defined in state.py TypedDict
**Check**: Field is initialized in the invocation:
```python
result = await graph.ainvoke({
    "messages": [...],
    "session_id": "...",
    "metadata": {},
    # All required fields must be here
})
```

### 6. Import Errors

**Check**: Module paths match file locations
**Check**: `pyproject.toml` has all dependencies
**Check**: Virtual environment is activated

```bash
pip install -e .
python -c "from graph import graph; print('OK')"
```

### 7. LLM Not Responding

**Check**: API key is set in `.env`
**Check**: Model name is correct
**Check**: `config/settings.py` loads the right provider

## Diagnostic Commands

```bash
# Check if graph compiles
python -c "from graph import graph; print('Graph compiled:', graph)"

# List all nodes
python -c "from graph import graph; print(graph.get_graph().nodes)"

# Generate Mermaid diagram
python -c "from graph import graph; print(graph.get_graph().draw_mermaid())"

# Test a simple invocation
python -c "
import asyncio
from graph import graph
result = asyncio.run(graph.ainvoke({
    'messages': [{'role': 'user', 'content': 'hello'}],
    'session_id': 'debug',
    'metadata': {},
}))
print('Messages:', len(result.get('messages', [])))
if result.get('messages'):
    print('Last:', result['messages'][-1].content[:200])
"
```

## AOD Engine State Debugging

```bash
# Check applied skills
cat .aod/state.yaml

# Check if base snapshot exists
ls -la .aod/base/

# Verify skill application
python -c "
import yaml
with open('.aod/state.yaml') as f:
    state = yaml.safe_load(f)
for skill in state.get('applied_skills', []):
    print(f'{skill[\"name\"]} v{skill[\"version\"]} applied at {skill[\"applied_at\"]}')"
```

## Workflow

1. **Identify the symptom** — Which of the above categories?
2. **Read the relevant files** — graph.py, state.py, the agent file
3. **Run diagnostic commands** — Compile check, node list, test invocation
4. **Fix the root cause** — Usually a missing edge, wrong import, or state issue
5. **Verify** — Re-run the diagnostic and test
